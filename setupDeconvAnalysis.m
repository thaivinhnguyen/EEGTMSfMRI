function setupDeconvAnalysis(outputdir,feat_file,confound_file,stimTimes,extraRegressors,varargin)
% FUNCTION setupDeconvAnalysis(outputdir,feat_file,confound_file,stimTimes,extraRegressors,varargin)
%   *** INPUTS ***
%       outputdir: directory where deconv analysis will be saved
%                  directory will be created if it doesn't already exist
%       feat_file: filename for filtered func dataset
%       confound_file: filename for confound_file (set to '' to ignore)
%       stimTimes: (array) vector of stimulus onset times, in units of seconds
%       extraRegressors: a cell array of filenames for extra EV regressors
%                        (must be in 3-column format)
%
%   *** ADDITIONAL INPUTS ('Name',Value) pairs:
%       'estimationMethod': only 'LS-S' is supported
%       'convolveFn': (DEFAULT: 'Double-Gamma HRF')
%       'addTempDeriv': add temporal derivatives (DEFAULT: 1)
%       'stimOnsetDuration': duration of each stimulus, in seconds
%       (DEFAULT: 0.2)- also can set stimOnsetDuration as an array
%       'evorthog': matrix specifying how to orthogonalize regressors
%                   Must be a square matrix of size (2 + numel(extraRegressors))
%                   The 1st regressor indexes the signal regressor for
%                       each stimuls in the LS-S method
%                   The 2nd regressor indexes the noise regressor for each
%                       stimulus in the LS-S method
%                   The remaining regressors index those in extraRegressors
%
%                   If evorthog(i,j) = 1, then regressor #j is
%                       orthogonalized with respect to regressor #i
%   
%   Example run - setupDeconvAnalysis(fullfile(pwd,'deConv/block1'),fullfile(pwd,'filtered_func_data.nii.gz'),'confoundevs.txt',[5:5:460],[])
%
%   Written 3/18/2014 by BC
%   edited. 3/19/2014 by JM-added the ability to set durations for each
%   stimulus

    function writeEV(fp,ev)
        hasOrthog = min(sum(ev.evorthog),1);
        fprintf(fp,[sprintf('\n# EV %d title\n',ev.evnum),...
            sprintf('set fmri(evtitle%d) "%s"\n\n',ev.evnum,ev.evtitle),...
            sprintf('# Basic waveform shape (EV %d)\n',ev.evnum),...
            sprintf('# 0 : Square\n# 1 : Sinusoid\n# 2 : Custom (1 entry per volume)\n# 3 : Custom (3 column format)\n# 4 : Interaction\n# 10 : Empty (all zeros)\n'),...
            sprintf('set fmri(shape%d) 3\n\n',ev.evnum),...
            sprintf('# Convolution (EV %d)\n',ev.evnum),...
            sprintf('# 0 : None\n# 1 : Gaussian\n# 2 : Gamma\n# 3 : Double-Gamma HRF\n# 4 : Gamma basis functions\n# 5 : Sine basis functions\n# 6 : FIR basis functions\n'),...
            sprintf('set fmri(convolve%d) %d\n\n',ev.evnum,convolve_num),...
            sprintf('# Convolve phase (EV %d)\n',ev.evnum),...
            sprintf('set fmri(convolve_phase%d) 0\n\n',ev.evnum),...
            sprintf('# Apply temporal filtering (EV %d)\n',ev.evnum),...
            sprintf('set fmri(tempfilt_yn%d) 1\n\n',ev.evnum),...
            sprintf('# Add temporal derivative (EV %d)\n',ev.evnum),...
            sprintf('set fmri(deriv_yn%d) %d\n\n',ev.evnum,addTempDeriv),...
            sprintf('# Custom EV file (EV %d)\n',ev.evnum),...
            sprintf('set fmri(custom%d) "%s"\n\n',ev.evnum,ev.evfile),...
            sprintf('# Orthogonalize EV %d wrt 0\n',ev.evnum),...
            sprintf('set fmri(ortho%d.0) %d\n',ev.evnum,hasOrthog)]);
        for j=1:numel(ev.evorthog)
            fprintf(fp,[sprintf('\n# Orthogonalize EV %d wrt %d\n',ev.evnum,j),...
                sprintf('set fmri(ortho%d.%d) %d\n',ev.evnum,j,ev.evorthog(j))]);
        end
    end

    function templ = getJobTemplate
        templ = ['#!/bin/sh\n\n',...
                 '#$ -V\n',...
                 '#$ -o __OUTPUTDIR__/$JOB_NAME.$JOB_ID.out\n',...
                 '#$ -e __OUTPUTDIR__/$JOB_NAME.$JOB_ID.err\n',...
                 '#$ -S /bin/sh\n',...
                 'cd __OUTPUTDIR__\n',...
                 sprintf('%s %s -f design%d.fsf',python_loc,pygls_loc,stimNum)];
    end

    function templ = getMainClusterSubTemplate
        templ = ['#!/bin/sh\n\n',...
                 '#$ -V\n',...
                 '#$ -N deconvFMRI_submission_script.sh\n',...
                 '#$ -o /common/Users/psajda/Documents/Log/$JOB_NAME.$JOB_ID.out\n',...
                 '#$ -e /common/Users/psajda/Documents/Log/$JOB_NAME.$JOB_ID.err\n'];
        if numel(userEmail)
            templ = [templ,...
                     sprintf('#$ -M %s\n',userEmail)];
        end
        templ = [templ,...
                 '#$ -m e\n',...
                 '#\n',...
                 '##$ -pe threaded 8\n',...
                 '#\n\n',...
                 '__JOBS__\n\n'];
    end
                 
                 

if ~exist('extraRegressors','var'); extraRegressors = {}; end;
if ~isdir(outputdir); mkdir(outputdir); end;

defOpts = struct('estimationMethod','LS-S',...
    'convolveFn','Double-Gamma HRF',...
    'addTempDeriv',1,...
    'stimOnsetDuration',0.2,...
    'evorthog',[],...
    'python_loc','/common/Users/psajda/Library/Enthought/Canopy_64bit/User/bin/python',...
    'pygls_loc','/common/fsl/bin/pygls.py',...
    'userEmail','bc2468@columbia.edu');
opts = setOptsStruct(defOpts,varargin);
estimationMethod = opts.estimationMethod;
convolveFn = opts.convolveFn;
addTempDeriv = opts.addTempDeriv;
stimOnsetDuration = opts.stimOnsetDuration;
evorthog = opts.evorthog;
userEmail = opts.userEmail;
python_loc = opts.python_loc;
pygls_loc = opts.pygls_loc;

% Save out a params file
save(sprintf('%s/params.mat',outputdir),'outputdir','feat_file','confound_file','stimTimes','extraRegressors','opts');
clear defOpts opts;

if ~strcmp(estimationMethod,'LS-S')
    error('Only supports LS-S method currently.');
end

switch convolveFn
    case 'None', convolve_num = 0;
    case 'Gaussian', convolve_num = 1;
    case 'Gamma', convolve_num = 2;
    case 'Double-Gamma HRF', convolve_num = 3;
    case 'Gamma basis functions', convolve_num = 4;
    case 'Sine basis functions', convolve_num = 5;
    case 'FIR basis functions', convolve_num = 6;
    otherwise, error('Unknown convolveFn');
end

totalOrigRegressors = 2 + numel(extraRegressors);
totalRealRegressors = (1 + addTempDeriv)*totalOrigRegressors;
totalRealContrasts = 1;
totalOrigContrasts = 1;
if numel(confound_file)
    hasConfounds = 1;
else
    hasConfounds = 0;
end

if ~numel(evorthog), evorthog = zeros(totalOrigRegressors,totalOrigRegressors); end
if size(evorthog,1) ~= size(evorthog,2) || size(evorthog,1) ~= totalOrigRegressors
    error('evorthog must be a square matrix of size %d x %d',totalOrigRegressors,totalOrigRegressors);
end
if max(abs(diag(evorthog)))
    error('diagonal of evorthog must be zero (can''t be orthogonalized to oneself');
end

% Call fslinfo to grab the number of volumes and TR
tr = -1;
npts = -1;
[~,info_str] = call_fsl(sprintf('fslinfo %s',feat_file));
info_lines = regexp(info_str,'\n','split');
for j=1:numel(info_lines)
    a = regexp(info_lines{j},'\s+','split');
    if strcmp(a{1},'dim4')
        npts = str2double(a{2});
    elseif strcmp(a{1},'pixdim4')
        tr = str2double(a{2});
    end
end
if tr == -1
    error('Could not parse TR from filtered func data file');
end
if npts == -1
    error('Could not parse number of volumes from filtered func data file');
end


f = getFSFVars;
for j = 1:numel(f)
    % Fill in values as necessary
    if strcmp(f(j).value,'__SET__')
        switch f(j).name
            case 'tr'
                f(j).value = tr;
            case 'npts'
                f(j).value = npts;
            case 'outputdir'
                f(j).value = outputdir;
            case 'evs_orig'
                f(j).value = totalOrigRegressors;
            case 'evs_real'
                f(j).value = totalRealRegressors;
            case 'ncon_orig'
                f(j).value = totalOrigContrasts;
            case 'ncon_real'
                f(j).value = totalRealContrasts;
            otherwise
                error('Unknown field');
        end
    end
end


% Now write out the EV file and contrast file stuff
nstims = numel(stimTimes);
% added by JM
if numel(stimOnsetDuration)==1
    stimMat = [assertVec(stimTimes,'col'),stimOnsetDuration*ones(nstims,1),ones(nstims,1)];
elseif numel(stimOnsetDuration)==numel(stimTimes)
    stimMat = [assertVec(stimTimes,'col'),stimOnsetDuration,ones(nstims,1)];
else
    error('stimTimes not the same size as stimOnsetDuration');
end

% This is where bash scripts for pygls will be saved
jobsDir = sprintf('%s/cluster_jobs',outputdir);
if ~isdir(jobsDir); mkdir(jobsDir); end;



% Write out all of the EV files and FSF files
clusterSubmissionFile = sprintf('%s/main_cluster_sub.sh',outputdir);
clusterSubmissionJobs = '';
for stimNum = 1:nstims
    jobTemplate = getJobTemplate;
    outDir = sprintf('%s/stimNum_%d',outputdir,stimNum);
    if ~isdir(outDir); mkdir(outDir); end;
    
    jobFile = sprintf('%s/job_submission_stimNum_%d.sh',jobsDir,stimNum);
    fp = fopen(jobFile,'w');
    fprintf(fp,strrep(jobTemplate,'__OUTPUTDIR__',outDir));
    fclose(fp);
    
    clusterSubmissionJobs = [sprintf('%s',clusterSubmissionJobs),...
                             sprintf('qsub -q long.q %s\n',jobFile)];
    
    fsffile = sprintf('%s/design%d.fsf',outDir,stimNum);
    evfile = sprintf('%s/ev_stimNum_%d.txt',outDir,stimNum);
    evnoise = sprintf('%s/ev_stimNum_%d_noise.txt',outDir,stimNum);
    
    % Reset the output directory
    for j=1:numel(f)
        if strcmp(f(j).name,'outputdir')
            f(j).value = outDir;
        end
    end
    
    % Write out the ev file for this stimulus
    dlmwrite(evfile,stimMat(stimNum,:),'\t');
    
    % Write out the ev file for the noise regressor (all other stimuli)
    stimMatNoise = stimMat(setdiff(1:size(stimMat,1),stimNum),:);
    [~,sortinds] = sort(stimMatNoise(:,1),'ascend');
    stimMatNoise = stimMatNoise(sortinds,:);
    dlmwrite(evnoise,stimMatNoise,'\t');
    
    % Now write out the FSF file
    fp = fopen(fsffile,'w');
    % Write out the main FSF variables
    for j=1:numel(f)
        if numel(f(j).comment)
            fprintf(fp,'%s\n',f(j).comment);
        end
        
        if ischar(f(j).value)
            fprintf(fp,'set fmri(%s) "%s"\n\n',f(j).name,f(j).value);
        elseif round(f(j).value) == f(j).value
            fprintf(fp,'set fmri(%s) %d\n\n',f(j).name,f(j).value);
        else
            fprintf(fp,'set fmri(%s) %f\n\n',f(j).name,f(j).value);
        end
    end
    
    % Now output the Feat directory stuff
    fprintf(fp,'# 4D AVW data or FEAT directory (1)\n');
    fprintf(fp,'set feat_files(1) "%s"\n\n',feat_file);
    fprintf(fp,'# Add confound EVs text file\n');
    fprintf(fp,'set fmri(confoundevs) %d\n\n',hasConfounds);
    fprintf(fp,'# Confound EVs text file for analysis 1\n');
    fprintf(fp,'set confoundev_files(1) "%s"\n',confound_file);
    
    % Now write out the EV files
    ev = struct('evnum',1,...
        'evtitle',sprintf('s%d',stimNum),...
        'evfile',evfile,...
        'evorthog',evorthog(:,1));
    writeEV(fp,ev);
    
    ev = struct('evnum',2,...
        'evtitle',sprintf('s%d noise',stimNum),...
        'evfile',evnoise,...
        'evorthog',evorthog(:,2));
    writeEV(fp,ev);
    
    for j=1:numel(extraRegressors)
        ev = struct('evnum',2+j,...
            'evtitle',sprintf('Extra Regressor #%d',j),...
            'evfile',extraRegressors{j},...
            'evorthog',evorthog(:,2+j));
        writeEV(fp,ev);
    end
    
    
    % Now write out the contrast header text
    fprintf(fp,'\n# Contrast & F-tests mode\n# real : control real EVs\n# orig : control original EVs\nset fmri(con_mode_old) orig\nset fmri(con_mode) orig\n');
    
    % Now do the contrasts
    % First do the real contrast
    % This also includes temporal derivatives as regressors
    connum = 1;
    contitle = sprintf('s%d',stimNum);
    convec = [1,zeros(1,totalOrigRegressors-1)];
    if addTempDeriv
        convec_real = zeros(2*totalOrigRegressors,1);
        convec_real(1:2:end) = convec;
    else
        convec_real = convec;
    end
    fprintf(fp,[sprintf('\n# Display images for contrast_real %d\n',connum),...
        sprintf('set fmri(conpic_real.%d) 1\n\n',connum),...
        sprintf('# Title for contrast_real %d\n',connum),...
        sprintf('set fmri(conname_real.%d) "%s"\n',connum,contitle)]);
    for j=1:numel(convec_real)
        fprintf(fp,[sprintf('\n# Real contrast_real vector %d element %d\n',connum,j),...
            sprintf('set fmri(con_real%d.%d) %.1f\n',connum,j,convec_real(j))]);
    end
    
    % Now do the contrast_orig
    fprintf(fp,[sprintf('\n# Display images for contrast_orig %d\n',connum),...
        sprintf('set fmri(conpic_orig.%d) 1\n\n',connum),...
        sprintf('# Title for contrast_orig %d\n',connum),...
        sprintf('set fmri(conname_orig.%d) "%s"\n\n',connum,contitle)]);
    for j=1:numel(convec)
        fprintf(fp,[sprintf('\n# Real contrast_orig vector %d element %d\n',connum,j),...
            sprintf('set fmri(con_orig%d.%d) %.1f\n',connum,j,convec(j))]);
    end
    
    
    % Now write out the footer text
    fprintf(fp,['\n##########################################################\n',...
        '# Now options that don''t appear in the GUI\n\n',...
        '# Alternative (to BETting) mask image\n',...
        'set fmri(alternative_mask) ""\n\n',...
        '# Initial structural space registration initialisation transform\n',...
        'set fmri(init_initial_highres) ""\n\n',...
        '# Structural space registration initialisation transform\n',...
        'set fmri(init_highres) ""\n\n',...
        '# Standard space registration initialisation transform\n',...
        'set fmri(init_standard) ""\n\n',...
        '# For full FEAT analysis: overwrite existing .feat output dir?\n',...
        'set fmri(overwrite_yn) 1\n']);
    
    fclose(fp);
end

clusterSubFile = strrep(getMainClusterSubTemplate,'__JOBS__',clusterSubmissionJobs);
fp = fopen(clusterSubmissionFile,'w');
fprintf(fp,clusterSubFile);
fclose(fp);


end



function f = getFSFVars

% Use sprintf on comments to make sure that \n is interpreted correctly

i = 1;
f(i) = struct('name','version',...
    'value',6.00,...
    'comment',sprintf('# FEAT version number'));
i = i + 1;
f(i) = struct('name','inmelodic',...
    'value',0,...
    'comment',sprintf('# Are we in MELODIC?'));
i = i + 1;

f(i) = struct('name','inmelodic',...
    'value',0,...
    'comment',sprintf('# Are we in MELODIC?'));
i = i + 1;

f(i) = struct('name','level',...
    'value',1,...
    'comment',sprintf('# Analysis level\n# 1 : First-level analysis\n# 2 : Higher-level analysis'));
i = i + 1;

f(i) = struct('name','analysis',...
    'value',2,...
    'comment',sprintf('# Which stages to run\n# 0 : No first-level analysis (registration and/or group stats only)\n# 7 : Full first-level analysis\n# 1 : Pre-Stats\n# 3 : Pre-Stats + Stats\n# 2 :             Stats\n# 6 :             Stats + Post-stats\n# 4 :                     Post-stats'));
i = i + 1;

f(i) = struct('name','relative_yn',...
    'value',0,...
    'comment',sprintf('# Use relative filenames'));
i = i + 1;

f(i) = struct('name','help_yn',...
    'value',1,...
    'comment',sprintf('# Balloon help'));
i = i + 1;

f(i) = struct('name','featwatcher_yn',...
    'value',0,...
    'comment',sprintf('# Run Featwatcher'));
i = i + 1;

f(i) = struct('name','sscleanup_yn',...
    'value',0,...
    'comment',sprintf('# Cleanup first-level standard-space images'));
i = i + 1;

f(i) = struct('name','outputdir',...
    'value','__SET__',...
    'comment',sprintf('# Output directory'));
i = i + 1;

f(i) = struct('name','tr',...
    'value','__SET__',...
    'comment',sprintf('# TR(s)'));
i = i + 1;

f(i) = struct('name','npts',...
    'value','__SET__',...
    'comment',sprintf('# Total volumes'));
i = i + 1;

f(i) = struct('name','ndelete',...
    'value',0,...
    'comment',sprintf('# Delete volumes'));
i = i + 1;

f(i) = struct('name','tagfirst',...
    'value',1,...
    'comment',sprintf('# Perfusion tag/control order'));
i = i + 1;

f(i) = struct('name','multiple',...
    'value',1,...
    'comment',sprintf('# Number of first-level analyses'));
i = i + 1;

f(i) = struct('name','inputtype',...
    'value',1,...
    'comment',sprintf('# Higher-level input type\n# 1 : Inputs are lower-level FEAT directories\n# 2 : Inputs are cope images from FEAT directories'));
i = i + 1;

f(i) = struct('name','filtering_yn',...
    'value',0,...
    'comment',sprintf('# Carry out pre-stats processing?'));
i = i + 1;

f(i) = struct('name','brain_thresh',...
    'value',10,...
    'comment',sprintf('# Brain/background threshold, %%'));
i = i + 1;

f(i) = struct('name','critical_z',...
    'value',5.3,...
    'comment',sprintf('# Critical z for design efficiency calculation'));
i = i + 1;

f(i) = struct('name','noise',...
    'value',0.5,...
    'comment',sprintf('# Noise level'));
i = i + 1;

f(i) = struct('name','noisear',...
    'value',0.15,...
    'comment',sprintf('# Noise AR(1)'));
i = i + 1;

f(i) = struct('name','newdir_yn',...
    'value',0,...
    'comment',sprintf('# Post-stats-only directory copying\n# 0 : Overwrite original post-stats results\n# 1 : Copy original FEAT directory for new Contrasts, Thresholding, Rendering'));
i = i + 1;

f(i) = struct('name','mc',...
    'value',1,...
    'comment',sprintf('# Motion correction\n# 0 : None\n# 1 : MCFLIRT'));
i = i + 1;

f(i) = struct('name','sh_yn',...
    'value',0,...
    'comment',sprintf('# Spin-history (currently obsolete)'));
i = i + 1;

f(i) = struct('name','regunwarp_yn',...
    'value',0,...
    'comment',sprintf('# B0 fieldmap unwarping?'));
i = i + 1;

f(i) = struct('name','dwell',...
    'value',0.7,...
    'comment',sprintf('# EPI dwell time (ms)'));
i = i + 1;

f(i) = struct('name','te',...
    'value',35,...
    'comment',sprintf('# EPI TE (ms)'));
i = i + 1;

f(i) = struct('name','signallossthresh',...
    'value',10,...
    'comment',sprintf('# % Signal loss threshold'));
i = i + 1;

f(i) = struct('name','unwarp_dir',...
    'value','y-',...
    'comment',sprintf('# Unwarp direction'));
i = i + 1;

f(i) = struct('name','st',...
    'value',5,...
    'comment',sprintf('# Slice timing correction\n# 0 : None\n# 1 : Regular up (0, 1, 2, 3, ...)\n# 2 : Regular down\n# 3 : Use slice order file\n# 4 : Use slice timings file\n# 5 : Interleaved (0, 2, 4 ... 1, 3, 5 ... )'));
i = i + 1;

f(i) = struct('name','st_file',...
    'value','',...
    'comment',sprintf('# Slice timings file'));
i = i + 1;

f(i) = struct('name','bet_yn',...
    'value',1,...
    'comment',sprintf('# BET brain extraction'));
i = i + 1;

f(i) = struct('name','smooth',...
    'value',5,...
    'comment',sprintf('# Spatial smoothing FWHM (mm)'));
i = i + 1;

f(i) = struct('name','norm_yn',...
    'value',0,...
    'comment',sprintf('# Intensity normalization'));
i = i + 1;

f(i) = struct('name','perfsub_yn',...
    'value',0,...
    'comment',sprintf('# Perfusion subtraction'));
i = i + 1;

f(i) = struct('name','temphp_yn',...
    'value',1,...
    'comment',sprintf('# Highpass temporal filtering'));
i = i + 1;

f(i) = struct('name','templp_yn',...
    'value',0,...
    'comment',sprintf('# Lowpass temporal filtering'));
i = i + 1;

f(i) = struct('name','melodic_yn',...
    'value',0,...
    'comment',sprintf('# MELODIC ICA data exploration'));
i = i + 1;

f(i) = struct('name','stats_yn',...
    'value',1,...
    'comment',sprintf('# Carry out main stats?'));
i = i + 1;

f(i) = struct('name','prewhiten_yn',...
    'value',1,...
    'comment',sprintf('# Carry out prewhitening?'));
i = i + 1;

f(i) = struct('name','motionevs',...
    'value',0,...
    'comment',sprintf('# Add motion parameters to model\n# 0 : No\n# 1 : Yes'));
i = i + 1;

f(i) = struct('name','motionevsbeta',...
    'value','',...
    'comment',sprintf(''));
i = i + 1;

f(i) = struct('name','scriptevsbeta',...
    'value','',...
    'comment',sprintf(''));
i = i + 1;

f(i) = struct('name','robust_yn',...
    'value',0,...
    'comment',sprintf('# Robust outlier detection in FLAME?'));
i = i + 1;

f(i) = struct('name','mixed_yn',...
    'value',2,...
    'comment',sprintf('# Higher-level modelling\n# 3 : Fixed effects\n# 0 : Mixed Effects: Simple OLS\n# 2 : Mixed Effects: FLAME 1\n# 1 : Mixed Effects: FLAME 1+2'));
i = i + 1;

f(i) = struct('name','evs_orig',...
    'value','__SET__',...
    'comment',sprintf('# Number of EVs'));
i = i + 1;

f(i) = struct('name','evs_real',...
    'value','__SET__',...
    'comment',sprintf(''));
i = i + 1;

f(i) = struct('name','evs_vox',...
    'value',0,...
    'comment',sprintf(''));
i = i + 1;

f(i) = struct('name','ncon_orig',...
    'value','__SET__',...
    'comment',sprintf('# Number of contrasts'));
i = i + 1;

f(i) = struct('name','ncon_real',...
    'value','__SET__',...
    'comment',sprintf(''));
i = i + 1;

f(i) = struct('name','nftests_orig',...
    'value',0,...
    'comment',sprintf('# Number of F-tests'));
i = i + 1;

f(i) = struct('name','nftests_real',...
    'value',0,...
    'comment',sprintf(''));
i = i + 1;

f(i) = struct('name','constcol',...
    'value',0,...
    'comment',sprintf('# Add constant column to design matrix? (obsolete)'));
i = i + 1;

f(i) = struct('name','poststats_yn',...
    'value',0,...
    'comment',sprintf('# Carry out post-stats steps?'));
i = i + 1;

f(i) = struct('name','threshmask',...
    'value','',...
    'comment',sprintf('# Pre-threshold masking?'));
i = i + 1;

f(i) = struct('name','thresh',...
    'value',3,...
    'comment',sprintf('# Thresholding\n# 0 : None\n# 1 : Uncorrected\n# 2 : Voxel\n# 3 : Cluster'));
i = i + 1;

f(i) = struct('name','prob_thresh',...
    'value',0.05,...
    'comment',sprintf('# P threshold'));
i = i + 1;

f(i) = struct('name','z_thresh',...
    'value',2.3,...
    'comment',sprintf('# Z threshold'));
i = i + 1;

f(i) = struct('name','zdisplay',...
    'value',0,...
    'comment',sprintf('# Z min/max for colour rendering\n# 0 : Use actual Z min/max\n# 1 : Use preset Z min/max'));
i = i + 1;

f(i) = struct('name','zmin',...
    'value',2,...
    'comment',sprintf('# Z min in colour rendering'));
i = i + 1;

f(i) = struct('name','zmax',...
    'value',8,...
    'comment',sprintf('# Z max in colour rendering'));
i = i + 1;

f(i) = struct('name','rendertype',...
    'value',1,...
    'comment',sprintf('# Colour rendering type\n# 0 : Solid blobs\n# 1 : Transparent blobs'));
i = i + 1;

f(i) = struct('name','bgimage',...
    'value',1,...
    'comment',sprintf('# Background image for higher-level stats overlays\n# 1 : Mean highres\n# 2 : First highres\n# 3 : Mean functional\n# 4 : First functional\n# 5 : Standard space template'));
i = i + 1;

f(i) = struct('name','tsplot_yn',...
    'value',0,...
    'comment',sprintf('# Create time series plots'));
i = i + 1;

f(i) = struct('name','reg_yn',...
    'value',1,...
    'comment',sprintf('# Registration?'));
i = i + 1;

f(i) = struct('name','reginitial_highres_yn',...
    'value',0,...
    'comment',sprintf('# Registration to initial structural'));
i = i + 1;

f(i) = struct('name','reginitial_highres_search',...
    'value',90,...
    'comment',sprintf('# Search space for registration to initial structural\n# 0   : No search\n# 90  : Normal search\n# 180 : Full search'));
i = i + 1;

f(i) = struct('name','reginitial_highres_dof',...
    'value',3,...
    'comment',sprintf('# Degrees of Freedom for registration to initial structural'));
i = i + 1;

f(i) = struct('name','reghighres_yn',...
    'value',0,...
    'comment',sprintf('# Registration to main structural'));
i = i + 1;

f(i) = struct('name','reghighres_search',...
    'value',90,...
    'comment',sprintf('# Search space for registration to main structural\n# 0   : No search\n# 90  : Normal search\n# 180 : Full search'));
i = i + 1;

f(i) = struct('name','reghighres_dof',...
    'value','BBR',...
    'comment',sprintf('# Degrees of Freedom for registration to main structural'));
i = i + 1;

f(i) = struct('name','regstandard_yn',...
    'value',0,...
    'comment',sprintf('# Registration to standard image?'));
i = i + 1;

f(i) = struct('name','alternateReference_yn',...
    'value',0,...
    'comment',sprintf('# Use alternate reference images?'));
i = i + 1;

f(i) = struct('name','regstandard',...
    'value','/Applications/fsl/data/standard/MNI152_T1_2mm_brain',...
    'comment',sprintf('# Standard image'));
i = i + 1;

f(i) = struct('name','regstandard_search',...
    'value',90,...
    'comment',sprintf('# Search space for registration to standard space\n# 0   : No search\n# 90  : Normal search\n# 180 : Full search'));
i = i + 1;

f(i) = struct('name','regstandard_dof',...
    'value',12,...
    'comment',sprintf('# Degrees of Freedom for registration to standard space'));
i = i + 1;

f(i) = struct('name','regstandard_nonlinear_yn',...
    'value',1,...
    'comment',sprintf('# Do nonlinear registration from structural to standard space?'));
i = i + 1;

f(i) = struct('name','regstandard_nonlinear_warpres',...
    'value',10,...
    'comment',sprintf('# Control nonlinear warp field resolution'));
i = i + 1;

f(i) = struct('name','paradigm_hp',...
    'value',100,...
    'comment',sprintf('# High pass filter cutoff'));
i = i + 1;

f(i) = struct('name','totalVoxels',...
    'value',34406400,...
    'comment',sprintf('# Total voxels'));
i = i + 1;

f(i) = struct('name','ncopeinputs',...
    'value',0,...
    'comment',sprintf('# Number of lower-level copes feeding into higher-level analysis'));
i = i + 1;
end
